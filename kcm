#! /bin/bash 

export kcm_home
export kcm_env_home
export kcm_ifs_backup

chef_home="${chef_home:-${HOME}/.chef}"

# Creates the directory if it doesn't already exist.
#
dir_create_if_missing() {
	if [[ ! -d "$1" ]] 
	then 
		mkdir "$1"
	fi
}

# Echoes a non-blank string, if the provided 
# string only contains whitespace. 
#
str_is_blank() {
	echo "$1" | grep '^\s*$' 
}

# Echoes the input string with leading 
# and ending whitespace removed
#
str_strip_whitespace() {
	echo $(echo "$1" | sed 's/^\s*//') | sed 's/\s*$//'
}

# Sets up the kcm environment, as well as the
# current bash environment
# 
setup() {
	kcm_ifs_backup=$IFS
	IFS=$'\n'

	kcm_home="${kcm_home:-${HOME}/.kcm}"
	dir_create_if_missing "$kcm_home"

	kcm_env_home="$kcm_home/environments"
	dir_create_if_missing "$kcm_env_home"

	kcm_env_default="$kcm_env_home/system"
	dir_create_if_missing "$kcm_env_default"

	# If the current chef home isn't a symlink, then 
	# we need to store its contents into the "system"
	# environment
	if [[ -d "$chef_home" && ! -L "$chef_home" ]]
	then
		files=($(builtin cd "$chef_home" ; find . -maxdepth 1 -mindepth 1 -print | sed "s/^\.\///" )) 
		for file in "${files[@]}"
		do
			$(builtin cd "$chef_home" ; mv "$file" "$kcm_env_home/system/$file")
		done
	fi
}

# Restores the default internal field separator
# 
teardown() {
	IFS=$kcm_ifs_backup
}

# Logs a message out in a friendly green color. 
#
log_info() {
	echo -e "$(tput setaf 2)$1$(tput sgr0)"
}

# Logs a message out in a unfriendly red color. 
# The use should clearly know that something
# has gone wrong.
#
log_error() {
	echo -e "$(tput setaf 1)$1$(tput sgr0)"
}

# List the current kcm environments in a 
# human readable form.
#
kcm_list() {
	local list=($(kcm_list_string))
	local current=$(kcm_current)

	for dir in "${list[@]}"
	do
		if [ "$dir" == "$current" ]
		then
			log_info "$current *"
		else
			echo "$dir"
		fi
	done
}

# List the current kcm environments in
# a list of strings.  Each element will
# be separated by a newline.
# 
kcm_list_string() {
	local list=($(builtin cd "$kcm_env_home" ; find . -maxdepth 1 -mindepth 1 -type d -print | sed 's|\.\/||' | sort ))

	for dir in "${list[@]}"
	do
		echo "$dir"
	done
}

# Print the current kcm environment.
# 
kcm_current() {
	local current="$(kcm_current_string)" 

	if [[ "$current" == "" ]]
	then
		echo "Not using any environment."
		exit 1
	fi

	echo "$current"
}

# Print the current environment in a simple
# string form.  If the environment doesn't
# exist, then an empty string is printed.
# 
kcm_current_string() {
	if [[ ! -L "$chef_home" ]]
	then
		echo
		exit 0
	fi

	echo "$(readlink "$chef_home" | sed 's|\/\([^\/]\+\/\)*||')"
}

# Create a knew kcm environment
# 
kcm_create() {
	if [[ $# -ne 1 ]] || str_is_blank "$1"
	then
		log_error "Must supply a knife environment."
		exit 1
	fi

	local env=$(str_strip_whitespace "$1")

	if [[ -d  "$kcm_env_home/$env" ]]
	then
		log_error "That knife environment already exists."
		exit 1
	fi

	mkdir "$kcm_env_home/$env"
	log_info "Successfully created knife environment: $env"
	kcm_use "$env"
}

# Delete a kcm environment.
# 
kcm_delete() {
	if [[ $# -ne 1 ]] || str_is_blank "$1"
	then
		log_error "Must supply a knife environment."
		exit 1
	fi

	local env=$(str_strip_whitespace "$1")

	if [[ ! -d  "$kcm_env_home/$env" ]]
	then
		log_error "That knife environment does not exist."
		exit 1
	fi

	printf "Are you sure (y|n):" 
	read answer

	if [[ "$answer" != "y" ]] 
	then
		echo "Aborted"
		exit 0
	fi

	local current="$(kcm_current_string)" 
	if [[ "$current" == "$env" ]]
	then
		kcm_unuse
	fi

	log_info "Deleting: $env"
	rm -fr "$kcm_env_home/$env"
}

# Set a kcm environment as the one currently 
# being used.
# 
kcm_use() {
	if [[ $# -ne 1 ]] || str_is_blank "$1"
	then
		log_error "Must supply a knife environment."
		exit 1
	fi

	local env=$(str_strip_whitespace "$1")

	if [[ ! -d  "$kcm_env_home/$env" ]]
	then
		log_error "That knife environment does not exist."
		exit 1
	fi

	kcm_unuse 

	ln -s "$kcm_env_home/$env" "$chef_home"
	log_info "Now using knife environment: $env"
}

# Don't use any kcm environments
# 
kcm_unuse() {
	rm -r "$chef_home" &> /dev/null
}

# Get the info about the current environment
#
kcm_info() {
	local current=$(kcm_current_string)
	if [[ "$current" == "" ]] 
	then 
		log_error "Not using any environment."
		exit 1
	fi 

	log_info "$current"
	if [[ ! -f  "$chef_home/knife.rb" ]]
	then
		log_error "This environment has not been configured."
		exit 1
	fi

	cat "$chef_home/knife.rb"
}

kcm_usage() {
	printf "%b" "
	The following commands are available:
	"
	printf "%b" " 
	** Global Commands ** 
	"
	methods=( "list" )
	for method in "${methods[@]}" 
	do
		echo "kcm $method"
	done

	printf "%b" " 
	** Creation Commands ** 
	"
	methods=( "use" "create" "delete" )
	for method in "${methods[@]}" 
	do
		echo "kcm $method NAME"
	done

	printf "%b" " 
	** Current Environment Commands ** 
	"
	methods=( "info" "current" "unuse" )
	for method in "${methods[@]}" 
	do
		echo "kcm $method"
	done

}

setup 
args=($*)
action="${args[0]}"
shift

case "$action" in
	list|current|unuse|create|delete|use|info)
		kcm_$action "$@"
		;;
	*)
		kcm_usage
		exit 1
		;;
esac
teardown

exit $?
